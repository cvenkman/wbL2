
### Объекты доменной области
Доменные объекты — это объекты в объектно-ориентированных компьютерных программах, выражающие сущности из модели предметной области, относящейся к программе, и реализующие бизнес-логику программы. Например, программа, управляющая заказами, может содержать такие доменные объекты, как «заказ», «позиция заказа», «счёт-фактура».

Доменные объекты инкапсулируют всю необходимую для программы информацию об объекте предметной области. Так, например, реальный сотрудник может иметь фамилию, имя, отчество, пол, возраст (модель предметной области), но, если в программе используются только фамилия и имя, то именно они будут включены в качестве атрибутов доменного объекта (уровень объектов предметной области).

## Сереализация
```
Сериализация (в программировании) — процесс перевода структуры данных в последовательность байтов. Обратной к операции сериализации является операция десериализации (структуризации) — создание структуры данных из битовой последовательности.
```

Сериализуем значения Golang, используя функцию Marshal(), в кусочек байтов. Вы десериализуете часть байтов в значение Golang, используя функцию Unmarshal(). Это так просто.

### Marshal
Функция Marshal() может принимать что угодно, что в Go означает пустой интерфейс и возвращает часть байтов и ошибку. Вот ее сигнатура:
```
func Marshal(v interface{}) ([]byte, error)
```
Если Marshal() не сможет сериализовать входное значение, она вернет ненулевую ошибку. У Marshal() есть некоторые строгие ограничения (позже мы увидим, как их преодолеть с помощью пользовательских маршаллеров):

Ключи карты должны быть строками.
Значения карты должны иметь типы, сериализуемые пакетом json.
Следующие типы не поддерживаются: Channel, complex и function.
Циклические структуры данных не поддерживаются.
Указатели будут закодированы (и позже декодированы) как значения, на которые они указывают (или «null», если указатель равен нулю).

### Unmarshal
Функция Unmarshal() принимает фрагмент байта, который, как мы надеемся, представляет действительный JSON, и целевой интерфейс, который обычно является указателем на структуру или базовый тип. Он десериализует JSON в интерфейс универсальным способом. Если сериализация не удалась, он вернет ошибку. Вот сигнатура:
```
func Unmarshal(data []byte, v interface{}) error
```



## Server

```go
func main() {
    // обработчик, возвращающий «Hello World!»
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "Hello World!")
    })
    http.ListenAndServe(":80", nil)
}
```

### HTTP-обработчики (handler)
Обработчиком называется то, что принимает запрос и возвращает ответ. В Go обработчики реализуют интерфейс со следующей сигнатурой:c
```
type Handler interface {
        ServeHTTP(ResponseWriter, *Request)
}
```
Наш первый пример использует вспомогательную функцию http.HandleFunc, которая оборачивает другую функцию, принимающую http.ResponseWriter и http.Request, в ServeHTTP.

Идея представить обработчики единым интерфейсом открывает много возможностей. Позже мы увидим, что промежуточная обработка запросов будет реализована обработчиком, чей метод ServeHTTP выполняет некоторый код, а после вызывает метод ServeHTTP другого обработчика.

Таким образом, обработчики формируют ответы на запросы. Но как понять, какой именно обработчик нужно использовать в данный момент?

### Маршрутизация запросов
Для выбора обработчика запроса в Go используется HTTP-мультиплексор. В некоторых библиотеках он называется «muxer» или «router», но суть та же. Мультиплексор выбирает обработчик на основе анализа пути запроса.

### Обработка запросов
Наконец, нам необходимо что-то, способное слушать входящие соединения и перенаправлять каждый запрос соответствующему обработчику. Эту задачу можно возложить на http.Server.

Как мы увидим далее, сервер отвечает за всё, что связано с обработкой соединений. В нашем примере при вызове http.ListenAndServe используется стандартный HTTP-сервер.

