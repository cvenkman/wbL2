## Содержание
* [Парадигмы](#Прадигмы)
  - [Императивное программирование](#Императивное)
    * [Структурное](#Структурное)
    * [Процедурное](#Процедурное)
    * [Объектно-ориентированное](#ооп)
  - [Декларативное программирование](#Декларативное)
* [Паттерны](#Паттерны)
  - [Из чего состоит паттерн](#состоит)
  - [Классификация паттернов](#классификация)
  - [Как решать задачи проектирования с помощью паттернов](#решать)

# Прадигмы <a name="Прадигмы"></a>
Способ программирования, независящий от языка.
Совокупность идей и понятий, определяющих стиль написания компьютерных программ (подход к программированию).

Три известные парадигмы (структурная, ООП, функциональная) были открыты в течение десяти
лет, между 1958 и 1968 годами. За многие последующие десятилетия не появилось ни одной новой парадигмы.

## Императивное программирование <a name="Императивное"></a>

Что мы делаем

C#, Ruby, Java, C++, Python

Программный код в императивном стиле организован как последовательность отдельных команд, инструкций, описывающих логику работы программы. Читая такой код, можно понять, каким образом будет меняться состояние приложения в тот или иной момент — в зависимости от того, какие фрагменты кода будут запущены.

Подвиды:

0. Структурное программирование <a name="Структурное"></a>

Любая программа, которая строится без использования оператора goto, состоит из трёх базовых управляющих конструкций: последовательность, ветвление, цикл; кроме того, используются подпрограммы. При этом разработка программы ведётся пошагово, методом «сверху вниз».

Структурное программирование накладывает ограничение на прямую передачу управления (инструкции
goto).

1. Процедурное программирование <a name="Процедурное"></a>

Алгоритм выполнения программы представлен как последовательность инструкций, которые организованы в специальные блоки кода, процедуры (подпрограммы), которые можно вызывать много раз из любой точки программы.

Легко разобраться, с ростом проекта сложно поддерживать и масштабировать.

2. Объектно-ориентированное программирование <a name="ооп"></a>

Разделение на объекты и классы.

* объект — это элементарная сущность, имеющая свойства (атрибуты) и поведение (методы, они же — бывшие процедуры);
* класс — это тип, шаблон, определяющий структуру, набор атрибутов и методов для объектов одного типа — то есть, экземпляров класса;
класс может наследовать атрибуты и методы своего родительского класса и иметь при этом свои собственные. Так формируется иерархия классов, она позволяет моделировать предметную область на разных уровнях абстракции и детализации, решая задачу по частям;
* полиморфизм — это механизм, позволяющий использовать одну и ту же функцию (метод) для данных разных типов (классов);
* инкапсуляция — это механизм, позволяющий скрывать некоторые детали реализации внутри класса. Часто сторонним сущностям, которые работают с объектом ни к чему знать нюансы реализации его класса и иметь доступ к каким-то его атрибутам и методам. Поэтому часто разработчик создает для класса интерфейс, которые отвечает за взаимодействие с внешними сущностями, открывая специально выбранные для этого атрибуты и методы.

Объектно-ориентированное программирование накладывает ограничение на
косвенную передачу управления (указатели на функции).

## Декларативное программирование <a name="Декларативное"></a>

Что мы хотим

LISP, SQL, Haskell, Scala

Подвиды:

1. Функциональное программирование
Функциональное программирование накладывает ограничение на присваивание.
2. Логическое программирование


# Паттерны <a name="Паттерны"></a>

```
Отношение вид-контроллер - это пример паттерна проектирования страте-
гия.
Но основные отношения
в схеме МУС описываются паттернами наблюдатель, компоновщик и стратегия.

выделить прееменные составляющие и инкапсулируйте их, чтобы позднее их можно было изменять или расщирять без воздействия на постоянные составяляющие.
```


Смысл паттерна — предложить решение определенной задачи в конкретном контексте.

```
«любой паттерн описывает задачу, которая снова и снова возникает в нашей работе, а также принцип ее решения, причем таким образом, что это решение можно потом использовать миллион раз, и при этом никакие две реализации не будут полностью одинаковыми»
```

* Паттерны проектирования дают разработчику возможность быстрее найти правильный путь.
* Паттерны обеспечивают возможность изменений некоторой части системы независимо от других частей.

Под паттернами проектирования
понимается описание взаимодействия объектов и классов, адаптированных
для решения общей задачи проектирования в конкретном контексте.

## Из чего состоит паттерн <a name="состоит"></a>

В общем случае паттерн состоит из четырех основных элементов:

1. Имя. Сославшись на него, мы можем сразу описать проблему проектирования; ее решения и их последствия. Присваивание паттернам имен позволяет проектировать на более высоком уровне абстракции. С помощью словаря паттернов можно вести обсуждение с коллегами, упоминать паттерны в документации, в тонкостях представлять дизайн системы. Нахождение хороших имен было одной из самых трудных задач при составлении каталога.

2. Задача. Описание того, когда следует применять паттерн. Необходимо сформулировать задачу и ее контекст. Может описываться конкретная проблема проектирования, например способ представления алгоритмов в виде объектов. Иногда отмечается, какие структуры классов или объектов свидетельствуют о негибком дизайне. Также может включаться перечень условий, при выполнении которых имеет смысл применять данный паттерн.

3. Решение. Описание элементов дизайна, отношений между ними, функций каждого элемента. Конкретный дизайн или реализация не имеются в виду, поскольку паттерн - это шаблон, применимый в самых разных ситуациях. Просто дается абстрактное описание задачи проектирования и того, как она может быть решена с помощью некоего весьма обобщенного сочетания элементов (в нашем случае классов и объектов).

4. Результаты - это следствия применения паттерна и разного рода компромиссы. Хотя при описании проектных решений о последствиях часто не упоминают, знать о них необходимо, чтобы можно было выбрать между различными вариантами и оценить преимущества и недостатки данного паттерна. Здесь речь идет и о выборе языка и реализации. Поскольку в объектно-ориентированном проектировании повторное использование зачастую является важным фактором, то к результатам следует относить и влияние на степень гибкости, расширяемости и переносимости системы.Перечисление всех последствий поможет вам понять и оценить их роль.

**Инкапсуляция**

Объектно-ориентированные программы состоят из объектов. Объект сочетает данные и процедуры для их обработки. Такие процедуры обычно называют методами или операциями. Объект выполняет операцию, когда получает запрос (или сообщение) от клиента.

Посылка запроса - это единственный способ заставить объект выполнить операцию. А выполнение операции - единственный способ изменить внутреннее состояние объекта. Имея в виду два эти ограничения, говорят, что внутреннее состояние объекта инкапсулировано: к нему нельзя получить непосредственный доступ, то есть представление объекта закрыто от внешней программы.

## Классификация паттернов <a name="классификация"></a>

Паттерны проектирования различаются степенью детализации и уровнем абстракции.

Паттерны классифицируются по двум критериям:
1. Цель - отражает назначение паттерна.
  * порождающие - связаны с процессом создания объектов
  * структурные - имеют отношение к композиции объектов и классов
  * паттерны поведения -  характеризуют то, как классы или объекты взаимодействуют
2. Уровень - сообщает, к чему обычно применяется паттерн: к объектам или классам.
  * уровня классов - описывают отношения между классами и их подклассами. Такие отношения выражаются с помощью наследования, поэтому они статичны, то есть зафиксированы на этапе компиляции. Примеры: Фабричный метод, Адаптер, Интерпретатор, Шаблонный метод
  * уровня объектов - описывают отношения между объектами, которые могут изменяться во время выполнения и потому более динамичны. 

```
Порождающие паттерны классов частично делегируют ответственность за создание объектов своим подклассам, тогда как порождающие паттерны
объектов передают ответственность другому объекту. Структурные паттерны классов используют наследование для составления классов, в то время как структурные паттерны объектов описывают способы сборки объектов из частей. Поведенческие паттерны классов используют наследование для описания алгоритмов и потока управления, а поведенческие паттерны объектов описывают, как объекты, принадлежащие некоторой группе, совместными усилиями выполняют задачу, которая ни одному отдельному объекту не под силу.
```

## Как решать задачи проектирования с помощью паттернов <a name="решать"></a>

* [Поиск подходящих объектов] (#объекты)
* [Определение степени детализации объекта] (#детализация)
* [Определение интерфейсов объекта] (#интерфейсы)


### Поиск подходящих объектов <a name="объекты"></a>
Самая трудная задача в объектно-ориентированном проектировании — разложить систему на объекты. 

Объектно-ориентированные программы состоят из объектов. Объект сочетает данные и процедуры для их обработки. Такие процедуры обычно называют методами или операциями. Объект выполняет операцию, когда получает запрос (или сообщение) от клиента.
Отправка запроса — это единственный способ заставить объект выполнить операцию. А выполнение операции — единственный способ изменить внутреннее состояние объекта. Из-за этих двух ограничений говорят, что внутреннее состояние объекта инкапсулировано: к нему нельзя обратиться напрямую, а его представление невидимо за пределами объекта.

Паттерн **компоновщик** вводит такую абстракцию для единообразной трактовки объектов, у которой нет физического аналога. 

Паттерны проектирования помогают выявить не вполне очевидные абстракции и объекты, которые могут их использовать. Например, объектов, представляющих процесс или алгоритм, в действительности нет, но они являются неотъемлемыми составляющими гибкого дизайна. Паттерн **стратегия** описывает способ реализации взаимозаменяемых семейств алгоритмов. Паттерн **состояние** представляет состояние некоторой сущности в виде объекта. Эти объекты редко возникают во время анализа и даже на ранних стадиях проектирования. Они появляются позднее, при попытках сделать дизайн более гибким и пригодным для повторного использования.

### Определение степени детализации объекта <a name="детализация"></a>
Размеры и число объектов могут изменяться в широком диапазоне. С помощью объектов можно представить все, от физических устройств до программ.
Как же решить, что должен представлять объект?

Паттерны проектирования помогут решить и эту проблему. Паттерн **фасад** показывает, как представить в виде объекта целые подсистемы, а паттерн приспособленец (231) — как поддерживать большое число объектов при высокой степени детализации. Другие паттерны указывают путь к разложению объекта на меньшие подобъекты. Абстрактная **фабрика** и **строитель** описывают объекты, единственной целью которых является создание других объектов, а **посетитель** и **команда** — объекты, отвечающие за реализацию запроса к другому объекту или группе.

### Определение интерфейсов объекта <a name="интерфейсы"></a>
Для любой операции, объявляемой объектом, должны быть заданы: имя операции, объекты, передаваемые в качестве параметров, и значение, возвращаемое операцией. Эту триаду называют сигнатурой операции. Множество сигнатур всех определенных для объекта операций называется интерфейсом этого объекта.  ***Интерфейс описывает все множество запросов, которые можно отправить объекту.*** Любой запрос, сигнатура которого входит винтерфейс объекта, может быть ему отправлен.

***Тип*** представляет собой имя, используемое для обозначения конкретного интерфейса. Говорят, что объект имеет тип Window, если он готов принимать запросы на выполнение любых операций, определенных в интерфейсе с именем Window.

У одного объекта может быть много типов. Интерфейсы могут содержать другие интерфейсы в качестве подмножеств. Мы говорим, что один тип является подтипом другого, если интерфейс первого содержит интерфейс второго. В этом случае второй тип называется ***супертипом*** для первого. Часто говорят также, что подтип наследует интерфейс своего супертипа.

Ассоциирование запроса с объектом и одной из его операций во время выполнения называется ***динамическим связыванием***. Динамическое связывание означает, что отправка некоторого запроса не определяет никакой конкретной реализации до момента выполнения. Следовательно, возможно написать программу, рассчитанную на объект с конкретным интерфейсом, точно зная, что любой объект с подходящим интерфейсом сможет принять этот запрос. Более того, динамическое связывание позволяет во время выполнения подставить вместо одного объекта другой, если он имеет идентичный интерфейс. Такая взаимозаменяемость называется ***полиморфизмом*** и является важнейшей особенностью объектноориентированных систем.